/*
Email Validation API â€” Enterprise-grade Email Verification

API robusta y segura para validaciÃ³n y verificaciÃ³n de correos electrÃ³nicos. Soporta verificaciÃ³n individual y en lote, detecciÃ³n de brechas, y autenticaciÃ³n JWT. Cumple con GDPR y dispone de planes de pago flexibles.  **ðŸ”— Enlaces importantes:** - [Estado del sistema](https://mailsafepro.betteruptime.com) - [DocumentaciÃ³n completa](https://api.mailsafepro.es/redoc)  **ðŸ“§ Contacto:** mailsafepro1@gmail.com

API version: 2.5.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailsafepro

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type APIKeysAPI interface {

	/*
	CreateApiKeyApiKeysPost Create Api Key

	Create a new API key with atomic transaction.
Generates cryptographically secure API keys with proper scoping
based on user's current plan. Enforces maximum key limits.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiKeyApiKeysPostRequest
	*/
	CreateApiKeyApiKeysPost(ctx context.Context) ApiCreateApiKeyApiKeysPostRequest

	// CreateApiKeyApiKeysPostExecute executes the request
	//  @return map[string]interface{}
	CreateApiKeyApiKeysPostExecute(r ApiCreateApiKeyApiKeysPostRequest) (map[string]interface{}, *http.Response, error)

	/*
	CreateApiKeyApiKeysPost_0 Create Api Key

	Create a new API key with atomic transaction.
Generates cryptographically secure API keys with proper scoping
based on user's current plan. Enforces maximum key limits.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateApiKeyApiKeysPost_0Request
	*/
	CreateApiKeyApiKeysPost_1(ctx context.Context) ApiCreateApiKeyApiKeysPost_0Request

	// CreateApiKeyApiKeysPost_1Execute executes the request
	//  @return map[string]interface{}
	CreateApiKeyApiKeysPost_1Execute(r ApiCreateApiKeyApiKeysPost_0Request) (map[string]interface{}, *http.Response, error)

	/*
	ForceSyncApiKeysForceSyncPost Force Sync

	Force synchronization of user data with rate limiting.
Synchronizes API keys with current plan and clears relevant caches.
Limited to one sync per 5 minutes per user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceSyncApiKeysForceSyncPostRequest
	*/
	ForceSyncApiKeysForceSyncPost(ctx context.Context) ApiForceSyncApiKeysForceSyncPostRequest

	// ForceSyncApiKeysForceSyncPostExecute executes the request
	//  @return map[string]interface{}
	ForceSyncApiKeysForceSyncPostExecute(r ApiForceSyncApiKeysForceSyncPostRequest) (map[string]interface{}, *http.Response, error)

	/*
	ForceSyncApiKeysForceSyncPost_0 Force Sync

	Force synchronization of user data with rate limiting.
Synchronizes API keys with current plan and clears relevant caches.
Limited to one sync per 5 minutes per user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiForceSyncApiKeysForceSyncPost_0Request
	*/
	ForceSyncApiKeysForceSyncPost_2(ctx context.Context) ApiForceSyncApiKeysForceSyncPost_0Request

	// ForceSyncApiKeysForceSyncPost_2Execute executes the request
	//  @return map[string]interface{}
	ForceSyncApiKeysForceSyncPost_2Execute(r ApiForceSyncApiKeysForceSyncPost_0Request) (map[string]interface{}, *http.Response, error)

	/*
	GetApiKeyValueApiKeysKeyHashValueGet Get Api Key Value

	Retrieve API key metadata (security-safe).
Returns key information without exposing the actual key value.
Used for key management and verification purposes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiGetApiKeyValueApiKeysKeyHashValueGetRequest
	*/
	GetApiKeyValueApiKeysKeyHashValueGet(ctx context.Context, keyHash string) ApiGetApiKeyValueApiKeysKeyHashValueGetRequest

	// GetApiKeyValueApiKeysKeyHashValueGetExecute executes the request
	//  @return map[string]interface{}
	GetApiKeyValueApiKeysKeyHashValueGetExecute(r ApiGetApiKeyValueApiKeysKeyHashValueGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetApiKeyValueApiKeysKeyHashValueGet_0 Get Api Key Value

	Retrieve API key metadata (security-safe).
Returns key information without exposing the actual key value.
Used for key management and verification purposes.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request
	*/
	GetApiKeyValueApiKeysKeyHashValueGet_3(ctx context.Context, keyHash string) ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request

	// GetApiKeyValueApiKeysKeyHashValueGet_3Execute executes the request
	//  @return map[string]interface{}
	GetApiKeyValueApiKeysKeyHashValueGet_3Execute(r ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request) (map[string]interface{}, *http.Response, error)

	/*
	GetUsageApiKeysUsageGet Get Usage

	Get current API usage statistics.
Returns usage count, limits, and remaining requests for today.
Works with both API keys and JWT tokens.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsageApiKeysUsageGetRequest
	*/
	GetUsageApiKeysUsageGet(ctx context.Context) ApiGetUsageApiKeysUsageGetRequest

	// GetUsageApiKeysUsageGetExecute executes the request
	//  @return map[string]interface{}
	GetUsageApiKeysUsageGetExecute(r ApiGetUsageApiKeysUsageGetRequest) (map[string]interface{}, *http.Response, error)

	/*
	GetUsageApiKeysUsageGet_0 Get Usage

	Get current API usage statistics.
Returns usage count, limits, and remaining requests for today.
Works with both API keys and JWT tokens.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUsageApiKeysUsageGet_0Request
	*/
	GetUsageApiKeysUsageGet_4(ctx context.Context) ApiGetUsageApiKeysUsageGet_0Request

	// GetUsageApiKeysUsageGet_4Execute executes the request
	//  @return map[string]interface{}
	GetUsageApiKeysUsageGet_4Execute(r ApiGetUsageApiKeysUsageGet_0Request) (map[string]interface{}, *http.Response, error)

	/*
	ListApiKeysApiKeysGet List Api Keys

	List all API keys for current user with consistent IDs.
Returns comprehensive key metadata including status, scopes, and usage information.
Handles corrupted key data gracefully.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListApiKeysApiKeysGetRequest
	*/
	ListApiKeysApiKeysGet(ctx context.Context) ApiListApiKeysApiKeysGetRequest

	// ListApiKeysApiKeysGetExecute executes the request
	//  @return APIKeyListResponse
	ListApiKeysApiKeysGetExecute(r ApiListApiKeysApiKeysGetRequest) (*APIKeyListResponse, *http.Response, error)

	/*
	ListApiKeysApiKeysGet_0 List Api Keys

	List all API keys for current user with consistent IDs.
Returns comprehensive key metadata including status, scopes, and usage information.
Handles corrupted key data gracefully.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListApiKeysApiKeysGet_0Request
	*/
	ListApiKeysApiKeysGet_5(ctx context.Context) ApiListApiKeysApiKeysGet_0Request

	// ListApiKeysApiKeysGet_5Execute executes the request
	//  @return APIKeyListResponse
	ListApiKeysApiKeysGet_5Execute(r ApiListApiKeysApiKeysGet_0Request) (*APIKeyListResponse, *http.Response, error)

	/*
	RepairUserDataEndpointApiKeysRepairDataPost Repair User Data Endpoint

	Emergency data repair endpoint - ADMINISTRATORS ONLY
WARNING: Critical operation; relies on admin scope verification at runtime.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRepairUserDataEndpointApiKeysRepairDataPostRequest
	*/
	RepairUserDataEndpointApiKeysRepairDataPost(ctx context.Context) ApiRepairUserDataEndpointApiKeysRepairDataPostRequest

	// RepairUserDataEndpointApiKeysRepairDataPostExecute executes the request
	//  @return map[string]string
	RepairUserDataEndpointApiKeysRepairDataPostExecute(r ApiRepairUserDataEndpointApiKeysRepairDataPostRequest) (map[string]string, *http.Response, error)

	/*
	RepairUserDataEndpointApiKeysRepairDataPost_0 Repair User Data Endpoint

	Emergency data repair endpoint - ADMINISTRATORS ONLY
WARNING: Critical operation; relies on admin scope verification at runtime.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request
	*/
	RepairUserDataEndpointApiKeysRepairDataPost_6(ctx context.Context) ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request

	// RepairUserDataEndpointApiKeysRepairDataPost_6Execute executes the request
	//  @return map[string]string
	RepairUserDataEndpointApiKeysRepairDataPost_6Execute(r ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request) (map[string]string, *http.Response, error)

	/*
	RevokeApiKeyApiKeysKeyHashRevokeDelete Revoke Api Key

	Revoke an API key with atomic transaction.
Immediately invalidates the key and removes it from active sets.
Provides audit trail for security compliance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest
	*/
	RevokeApiKeyApiKeysKeyHashRevokeDelete(ctx context.Context, keyHash string) ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest

	// RevokeApiKeyApiKeysKeyHashRevokeDeleteExecute executes the request
	//  @return interface{}
	RevokeApiKeyApiKeysKeyHashRevokeDeleteExecute(r ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest) (interface{}, *http.Response, error)

	/*
	RevokeApiKeyApiKeysKeyHashRevokeDelete_0 Revoke Api Key

	Revoke an API key with atomic transaction.
Immediately invalidates the key and removes it from active sets.
Provides audit trail for security compliance.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request
	*/
	RevokeApiKeyApiKeysKeyHashRevokeDelete_7(ctx context.Context, keyHash string) ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request

	// RevokeApiKeyApiKeysKeyHashRevokeDelete_7Execute executes the request
	//  @return interface{}
	RevokeApiKeyApiKeysKeyHashRevokeDelete_7Execute(r ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request) (interface{}, *http.Response, error)

	/*
	RotateApiKeyApiKeysKeyHashRotatePost Rotate Api Key

	Rotate API key with grace period.
Generates a new key while keeping the old one active for 7 days
to allow for smooth transition in client applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiRotateApiKeyApiKeysKeyHashRotatePostRequest
	*/
	RotateApiKeyApiKeysKeyHashRotatePost(ctx context.Context, keyHash string) ApiRotateApiKeyApiKeysKeyHashRotatePostRequest

	// RotateApiKeyApiKeysKeyHashRotatePostExecute executes the request
	//  @return map[string]interface{}
	RotateApiKeyApiKeysKeyHashRotatePostExecute(r ApiRotateApiKeyApiKeysKeyHashRotatePostRequest) (map[string]interface{}, *http.Response, error)

	/*
	RotateApiKeyApiKeysKeyHashRotatePost_0 Rotate Api Key

	Rotate API key with grace period.
Generates a new key while keeping the old one active for 7 days
to allow for smooth transition in client applications.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param keyHash
	@return ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request
	*/
	RotateApiKeyApiKeysKeyHashRotatePost_8(ctx context.Context, keyHash string) ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request

	// RotateApiKeyApiKeysKeyHashRotatePost_8Execute executes the request
	//  @return map[string]interface{}
	RotateApiKeyApiKeysKeyHashRotatePost_8Execute(r ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request) (map[string]interface{}, *http.Response, error)

	/*
	SyncPlanKeysApiKeysSyncPlanKeysPost Sync Plan Keys

	Synchronize current plan with all user API keys.
Ensures all existing keys have the correct scopes and permissions
based on the user's current subscription plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest
	*/
	SyncPlanKeysApiKeysSyncPlanKeysPost(ctx context.Context) ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest

	// SyncPlanKeysApiKeysSyncPlanKeysPostExecute executes the request
	//  @return map[string]interface{}
	SyncPlanKeysApiKeysSyncPlanKeysPostExecute(r ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest) (map[string]interface{}, *http.Response, error)

	/*
	SyncPlanKeysApiKeysSyncPlanKeysPost_0 Sync Plan Keys

	Synchronize current plan with all user API keys.
Ensures all existing keys have the correct scopes and permissions
based on the user's current subscription plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request
	*/
	SyncPlanKeysApiKeysSyncPlanKeysPost_9(ctx context.Context) ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request

	// SyncPlanKeysApiKeysSyncPlanKeysPost_9Execute executes the request
	//  @return map[string]interface{}
	SyncPlanKeysApiKeysSyncPlanKeysPost_9Execute(r ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request) (map[string]interface{}, *http.Response, error)
}

// APIKeysAPIService APIKeysAPI service
type APIKeysAPIService service

type ApiCreateApiKeyApiKeysPostRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
	aPIKeyCreateRequest *APIKeyCreateRequest
}

func (r ApiCreateApiKeyApiKeysPostRequest) APIKeyCreateRequest(aPIKeyCreateRequest APIKeyCreateRequest) ApiCreateApiKeyApiKeysPostRequest {
	r.aPIKeyCreateRequest = &aPIKeyCreateRequest
	return r
}

func (r ApiCreateApiKeyApiKeysPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateApiKeyApiKeysPostExecute(r)
}

/*
CreateApiKeyApiKeysPost Create Api Key

Create a new API key with atomic transaction.
Generates cryptographically secure API keys with proper scoping
based on user's current plan. Enforces maximum key limits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiKeyApiKeysPostRequest
*/
func (a *APIKeysAPIService) CreateApiKeyApiKeysPost(ctx context.Context) ApiCreateApiKeyApiKeysPostRequest {
	return ApiCreateApiKeyApiKeysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) CreateApiKeyApiKeysPostExecute(r ApiCreateApiKeyApiKeysPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.CreateApiKeyApiKeysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aPIKeyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("aPIKeyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aPIKeyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateApiKeyApiKeysPost_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
	aPIKeyCreateRequest *APIKeyCreateRequest
}

func (r ApiCreateApiKeyApiKeysPost_0Request) APIKeyCreateRequest(aPIKeyCreateRequest APIKeyCreateRequest) ApiCreateApiKeyApiKeysPost_0Request {
	r.aPIKeyCreateRequest = &aPIKeyCreateRequest
	return r
}

func (r ApiCreateApiKeyApiKeysPost_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateApiKeyApiKeysPost_1Execute(r)
}

/*
CreateApiKeyApiKeysPost_0 Create Api Key

Create a new API key with atomic transaction.
Generates cryptographically secure API keys with proper scoping
based on user's current plan. Enforces maximum key limits.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiKeyApiKeysPost_0Request
*/
func (a *APIKeysAPIService) CreateApiKeyApiKeysPost_1(ctx context.Context) ApiCreateApiKeyApiKeysPost_0Request {
	return ApiCreateApiKeyApiKeysPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) CreateApiKeyApiKeysPost_1Execute(r ApiCreateApiKeyApiKeysPost_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.CreateApiKeyApiKeysPost_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.aPIKeyCreateRequest == nil {
		return localVarReturnValue, nil, reportError("aPIKeyCreateRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.aPIKeyCreateRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceSyncApiKeysForceSyncPostRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiForceSyncApiKeysForceSyncPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ForceSyncApiKeysForceSyncPostExecute(r)
}

/*
ForceSyncApiKeysForceSyncPost Force Sync

Force synchronization of user data with rate limiting.
Synchronizes API keys with current plan and clears relevant caches.
Limited to one sync per 5 minutes per user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiForceSyncApiKeysForceSyncPostRequest
*/
func (a *APIKeysAPIService) ForceSyncApiKeysForceSyncPost(ctx context.Context) ApiForceSyncApiKeysForceSyncPostRequest {
	return ApiForceSyncApiKeysForceSyncPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) ForceSyncApiKeysForceSyncPostExecute(r ApiForceSyncApiKeysForceSyncPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.ForceSyncApiKeysForceSyncPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/force-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiForceSyncApiKeysForceSyncPost_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiForceSyncApiKeysForceSyncPost_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ForceSyncApiKeysForceSyncPost_2Execute(r)
}

/*
ForceSyncApiKeysForceSyncPost_0 Force Sync

Force synchronization of user data with rate limiting.
Synchronizes API keys with current plan and clears relevant caches.
Limited to one sync per 5 minutes per user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiForceSyncApiKeysForceSyncPost_0Request
*/
func (a *APIKeysAPIService) ForceSyncApiKeysForceSyncPost_2(ctx context.Context) ApiForceSyncApiKeysForceSyncPost_0Request {
	return ApiForceSyncApiKeysForceSyncPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) ForceSyncApiKeysForceSyncPost_2Execute(r ApiForceSyncApiKeysForceSyncPost_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.ForceSyncApiKeysForceSyncPost_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/force-sync"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiKeyValueApiKeysKeyHashValueGetRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiGetApiKeyValueApiKeysKeyHashValueGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetApiKeyValueApiKeysKeyHashValueGetExecute(r)
}

/*
GetApiKeyValueApiKeysKeyHashValueGet Get Api Key Value

Retrieve API key metadata (security-safe).
Returns key information without exposing the actual key value.
Used for key management and verification purposes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiGetApiKeyValueApiKeysKeyHashValueGetRequest
*/
func (a *APIKeysAPIService) GetApiKeyValueApiKeysKeyHashValueGet(ctx context.Context, keyHash string) ApiGetApiKeyValueApiKeysKeyHashValueGetRequest {
	return ApiGetApiKeyValueApiKeysKeyHashValueGetRequest{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) GetApiKeyValueApiKeysKeyHashValueGetExecute(r ApiGetApiKeyValueApiKeysKeyHashValueGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.GetApiKeyValueApiKeysKeyHashValueGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetApiKeyValueApiKeysKeyHashValueGet_3Execute(r)
}

/*
GetApiKeyValueApiKeysKeyHashValueGet_0 Get Api Key Value

Retrieve API key metadata (security-safe).
Returns key information without exposing the actual key value.
Used for key management and verification purposes.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request
*/
func (a *APIKeysAPIService) GetApiKeyValueApiKeysKeyHashValueGet_3(ctx context.Context, keyHash string) ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request {
	return ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) GetApiKeyValueApiKeysKeyHashValueGet_3Execute(r ApiGetApiKeyValueApiKeysKeyHashValueGet_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.GetApiKeyValueApiKeysKeyHashValueGet_3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageApiKeysUsageGetRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
	xAPIKey *string
	authorization *string
}

func (r ApiGetUsageApiKeysUsageGetRequest) XAPIKey(xAPIKey string) ApiGetUsageApiKeysUsageGetRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetUsageApiKeysUsageGetRequest) Authorization(authorization string) ApiGetUsageApiKeysUsageGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetUsageApiKeysUsageGetRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUsageApiKeysUsageGetExecute(r)
}

/*
GetUsageApiKeysUsageGet Get Usage

Get current API usage statistics.
Returns usage count, limits, and remaining requests for today.
Works with both API keys and JWT tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsageApiKeysUsageGetRequest
*/
func (a *APIKeysAPIService) GetUsageApiKeysUsageGet(ctx context.Context) ApiGetUsageApiKeysUsageGetRequest {
	return ApiGetUsageApiKeysUsageGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) GetUsageApiKeysUsageGetExecute(r ApiGetUsageApiKeysUsageGetRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.GetUsageApiKeysUsageGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-API-Key", r.xAPIKey, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsageApiKeysUsageGet_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
	xAPIKey *string
	authorization *string
}

func (r ApiGetUsageApiKeysUsageGet_0Request) XAPIKey(xAPIKey string) ApiGetUsageApiKeysUsageGet_0Request {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetUsageApiKeysUsageGet_0Request) Authorization(authorization string) ApiGetUsageApiKeysUsageGet_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiGetUsageApiKeysUsageGet_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.GetUsageApiKeysUsageGet_4Execute(r)
}

/*
GetUsageApiKeysUsageGet_0 Get Usage

Get current API usage statistics.
Returns usage count, limits, and remaining requests for today.
Works with both API keys and JWT tokens.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsageApiKeysUsageGet_0Request
*/
func (a *APIKeysAPIService) GetUsageApiKeysUsageGet_4(ctx context.Context) ApiGetUsageApiKeysUsageGet_0Request {
	return ApiGetUsageApiKeysUsageGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) GetUsageApiKeysUsageGet_4Execute(r ApiGetUsageApiKeysUsageGet_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.GetUsageApiKeysUsageGet_4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/usage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-API-Key", r.xAPIKey, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApiKeysApiKeysGetRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiListApiKeysApiKeysGetRequest) Execute() (*APIKeyListResponse, *http.Response, error) {
	return r.ApiService.ListApiKeysApiKeysGetExecute(r)
}

/*
ListApiKeysApiKeysGet List Api Keys

List all API keys for current user with consistent IDs.
Returns comprehensive key metadata including status, scopes, and usage information.
Handles corrupted key data gracefully.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApiKeysApiKeysGetRequest
*/
func (a *APIKeysAPIService) ListApiKeysApiKeysGet(ctx context.Context) ApiListApiKeysApiKeysGetRequest {
	return ApiListApiKeysApiKeysGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return APIKeyListResponse
func (a *APIKeysAPIService) ListApiKeysApiKeysGetExecute(r ApiListApiKeysApiKeysGetRequest) (*APIKeyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *APIKeyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.ListApiKeysApiKeysGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListApiKeysApiKeysGet_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiListApiKeysApiKeysGet_0Request) Execute() (*APIKeyListResponse, *http.Response, error) {
	return r.ApiService.ListApiKeysApiKeysGet_5Execute(r)
}

/*
ListApiKeysApiKeysGet_0 List Api Keys

List all API keys for current user with consistent IDs.
Returns comprehensive key metadata including status, scopes, and usage information.
Handles corrupted key data gracefully.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListApiKeysApiKeysGet_0Request
*/
func (a *APIKeysAPIService) ListApiKeysApiKeysGet_5(ctx context.Context) ApiListApiKeysApiKeysGet_0Request {
	return ApiListApiKeysApiKeysGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return APIKeyListResponse
func (a *APIKeysAPIService) ListApiKeysApiKeysGet_5Execute(r ApiListApiKeysApiKeysGet_0Request) (*APIKeyListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *APIKeyListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.ListApiKeysApiKeysGet_5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepairUserDataEndpointApiKeysRepairDataPostRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiRepairUserDataEndpointApiKeysRepairDataPostRequest) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.RepairUserDataEndpointApiKeysRepairDataPostExecute(r)
}

/*
RepairUserDataEndpointApiKeysRepairDataPost Repair User Data Endpoint

Emergency data repair endpoint - ADMINISTRATORS ONLY
WARNING: Critical operation; relies on admin scope verification at runtime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRepairUserDataEndpointApiKeysRepairDataPostRequest
*/
func (a *APIKeysAPIService) RepairUserDataEndpointApiKeysRepairDataPost(ctx context.Context) ApiRepairUserDataEndpointApiKeysRepairDataPostRequest {
	return ApiRepairUserDataEndpointApiKeysRepairDataPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *APIKeysAPIService) RepairUserDataEndpointApiKeysRepairDataPostExecute(r ApiRepairUserDataEndpointApiKeysRepairDataPostRequest) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RepairUserDataEndpointApiKeysRepairDataPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/repair-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request) Execute() (map[string]string, *http.Response, error) {
	return r.ApiService.RepairUserDataEndpointApiKeysRepairDataPost_6Execute(r)
}

/*
RepairUserDataEndpointApiKeysRepairDataPost_0 Repair User Data Endpoint

Emergency data repair endpoint - ADMINISTRATORS ONLY
WARNING: Critical operation; relies on admin scope verification at runtime.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request
*/
func (a *APIKeysAPIService) RepairUserDataEndpointApiKeysRepairDataPost_6(ctx context.Context) ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request {
	return ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]string
func (a *APIKeysAPIService) RepairUserDataEndpointApiKeysRepairDataPost_6Execute(r ApiRepairUserDataEndpointApiKeysRepairDataPost_0Request) (map[string]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RepairUserDataEndpointApiKeysRepairDataPost_6")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/repair-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.RevokeApiKeyApiKeysKeyHashRevokeDeleteExecute(r)
}

/*
RevokeApiKeyApiKeysKeyHashRevokeDelete Revoke Api Key

Revoke an API key with atomic transaction.
Immediately invalidates the key and removes it from active sets.
Provides audit trail for security compliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest
*/
func (a *APIKeysAPIService) RevokeApiKeyApiKeysKeyHashRevokeDelete(ctx context.Context, keyHash string) ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest {
	return ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return interface{}
func (a *APIKeysAPIService) RevokeApiKeyApiKeysKeyHashRevokeDeleteExecute(r ApiRevokeApiKeyApiKeysKeyHashRevokeDeleteRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RevokeApiKeyApiKeysKeyHashRevokeDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/revoke"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.RevokeApiKeyApiKeysKeyHashRevokeDelete_7Execute(r)
}

/*
RevokeApiKeyApiKeysKeyHashRevokeDelete_0 Revoke Api Key

Revoke an API key with atomic transaction.
Immediately invalidates the key and removes it from active sets.
Provides audit trail for security compliance.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request
*/
func (a *APIKeysAPIService) RevokeApiKeyApiKeysKeyHashRevokeDelete_7(ctx context.Context, keyHash string) ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request {
	return ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return interface{}
func (a *APIKeysAPIService) RevokeApiKeyApiKeysKeyHashRevokeDelete_7Execute(r ApiRevokeApiKeyApiKeysKeyHashRevokeDelete_0Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RevokeApiKeyApiKeysKeyHashRevokeDelete_7")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/revoke"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateApiKeyApiKeysKeyHashRotatePostRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiRotateApiKeyApiKeysKeyHashRotatePostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RotateApiKeyApiKeysKeyHashRotatePostExecute(r)
}

/*
RotateApiKeyApiKeysKeyHashRotatePost Rotate Api Key

Rotate API key with grace period.
Generates a new key while keeping the old one active for 7 days
to allow for smooth transition in client applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiRotateApiKeyApiKeysKeyHashRotatePostRequest
*/
func (a *APIKeysAPIService) RotateApiKeyApiKeysKeyHashRotatePost(ctx context.Context, keyHash string) ApiRotateApiKeyApiKeysKeyHashRotatePostRequest {
	return ApiRotateApiKeyApiKeysKeyHashRotatePostRequest{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) RotateApiKeyApiKeysKeyHashRotatePostExecute(r ApiRotateApiKeyApiKeysKeyHashRotatePostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RotateApiKeyApiKeysKeyHashRotatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
	keyHash string
}

func (r ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.RotateApiKeyApiKeysKeyHashRotatePost_8Execute(r)
}

/*
RotateApiKeyApiKeysKeyHashRotatePost_0 Rotate Api Key

Rotate API key with grace period.
Generates a new key while keeping the old one active for 7 days
to allow for smooth transition in client applications.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param keyHash
 @return ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request
*/
func (a *APIKeysAPIService) RotateApiKeyApiKeysKeyHashRotatePost_8(ctx context.Context, keyHash string) ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request {
	return ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request{
		ApiService: a,
		ctx: ctx,
		keyHash: keyHash,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) RotateApiKeyApiKeysKeyHashRotatePost_8Execute(r ApiRotateApiKeyApiKeysKeyHashRotatePost_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.RotateApiKeyApiKeysKeyHashRotatePost_8")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/{key_hash}/rotate"
	localVarPath = strings.Replace(localVarPath, "{"+"key_hash"+"}", url.PathEscape(parameterValueToString(r.keyHash, "keyHash")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SyncPlanKeysApiKeysSyncPlanKeysPostExecute(r)
}

/*
SyncPlanKeysApiKeysSyncPlanKeysPost Sync Plan Keys

Synchronize current plan with all user API keys.
Ensures all existing keys have the correct scopes and permissions
based on the user's current subscription plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest
*/
func (a *APIKeysAPIService) SyncPlanKeysApiKeysSyncPlanKeysPost(ctx context.Context) ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest {
	return ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) SyncPlanKeysApiKeysSyncPlanKeysPostExecute(r ApiSyncPlanKeysApiKeysSyncPlanKeysPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.SyncPlanKeysApiKeysSyncPlanKeysPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/sync-plan-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request struct {
	ctx context.Context
	ApiService APIKeysAPI
}

func (r ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.SyncPlanKeysApiKeysSyncPlanKeysPost_9Execute(r)
}

/*
SyncPlanKeysApiKeysSyncPlanKeysPost_0 Sync Plan Keys

Synchronize current plan with all user API keys.
Ensures all existing keys have the correct scopes and permissions
based on the user's current subscription plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request
*/
func (a *APIKeysAPIService) SyncPlanKeysApiKeysSyncPlanKeysPost_9(ctx context.Context) ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request {
	return ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *APIKeysAPIService) SyncPlanKeysApiKeysSyncPlanKeysPost_9Execute(r ApiSyncPlanKeysApiKeysSyncPlanKeysPost_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIKeysAPIService.SyncPlanKeysApiKeysSyncPlanKeysPost_9")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api-keys/sync-plan-keys"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
