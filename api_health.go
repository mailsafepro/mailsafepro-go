/*
Email Validation API â€” Enterprise-grade Email Verification

API robusta y segura para validaciÃ³n y verificaciÃ³n de correos electrÃ³nicos. Soporta verificaciÃ³n individual y en lote, detecciÃ³n de brechas, y autenticaciÃ³n JWT. Cumple con GDPR y dispone de planes de pago flexibles.  **ðŸ”— Enlaces importantes:** - [Estado del sistema](https://mailsafepro.betteruptime.com) - [DocumentaciÃ³n completa](https://api.mailsafepro.es/redoc)  **ðŸ“§ Contacto:** mailsafepro1@gmail.com

API version: 2.5.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailsafepro

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type HealthAPI interface {

	/*
	BasicHealthHealthGet Basic health check

	Basic health check for load balancers.

Returns 200 if service is running.
Fast response, no dependency checks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBasicHealthHealthGetRequest
	*/
	BasicHealthHealthGet(ctx context.Context) ApiBasicHealthHealthGetRequest

	// BasicHealthHealthGetExecute executes the request
	//  @return interface{}
	BasicHealthHealthGetExecute(r ApiBasicHealthHealthGetRequest) (interface{}, *http.Response, error)

	/*
	BasicHealthHealthGet_0 Basic health check

	Basic health check for load balancers.

Returns 200 if service is running.
Fast response, no dependency checks.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiBasicHealthHealthGet_0Request
	*/
	BasicHealthHealthGet_1(ctx context.Context) ApiBasicHealthHealthGet_0Request

	// BasicHealthHealthGet_1Execute executes the request
	//  @return interface{}
	BasicHealthHealthGet_1Execute(r ApiBasicHealthHealthGet_0Request) (interface{}, *http.Response, error)

	/*
	CircuitBreakerStatusAdminCircuitBreakerStatusGet Circuit Breaker Status

	âœ… Circuit breaker status for all services.
Shows state of Redis, SMTP, DNS, and other circuit breakers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest
	*/
	CircuitBreakerStatusAdminCircuitBreakerStatusGet(ctx context.Context) ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest

	// CircuitBreakerStatusAdminCircuitBreakerStatusGetExecute executes the request
	//  @return interface{}
	CircuitBreakerStatusAdminCircuitBreakerStatusGetExecute(r ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest) (interface{}, *http.Response, error)

	/*
	DetailedHealthHealthDetailedGet Detailed health check

	Detailed health check with all component statuses.

Returns comprehensive health information for monitoring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDetailedHealthHealthDetailedGetRequest
	*/
	DetailedHealthHealthDetailedGet(ctx context.Context) ApiDetailedHealthHealthDetailedGetRequest

	// DetailedHealthHealthDetailedGetExecute executes the request
	//  @return interface{}
	DetailedHealthHealthDetailedGetExecute(r ApiDetailedHealthHealthDetailedGetRequest) (interface{}, *http.Response, error)

	/*
	DetailedHealthHealthDetailedGet_0 Detailed health check

	Detailed health check with all component statuses.

Returns comprehensive health information for monitoring.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDetailedHealthHealthDetailedGet_0Request
	*/
	DetailedHealthHealthDetailedGet_2(ctx context.Context) ApiDetailedHealthHealthDetailedGet_0Request

	// DetailedHealthHealthDetailedGet_2Execute executes the request
	//  @return interface{}
	DetailedHealthHealthDetailedGet_2Execute(r ApiDetailedHealthHealthDetailedGet_0Request) (interface{}, *http.Response, error)

	/*
	HealthcheckHealthcheckGet Healthcheck

	Basic health check endpoint (backward compatibility)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthcheckHealthcheckGetRequest
	*/
	HealthcheckHealthcheckGet(ctx context.Context) ApiHealthcheckHealthcheckGetRequest

	// HealthcheckHealthcheckGetExecute executes the request
	//  @return interface{}
	HealthcheckHealthcheckGetExecute(r ApiHealthcheckHealthcheckGetRequest) (interface{}, *http.Response, error)

	/*
	HealthcheckHealthcheckHead Healthcheck

	Basic health check endpoint (backward compatibility)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHealthcheckHealthcheckHeadRequest
	*/
	HealthcheckHealthcheckHead(ctx context.Context) ApiHealthcheckHealthcheckHeadRequest

	// HealthcheckHealthcheckHeadExecute executes the request
	//  @return interface{}
	HealthcheckHealthcheckHeadExecute(r ApiHealthcheckHealthcheckHeadRequest) (interface{}, *http.Response, error)

	/*
	LivenessCheckHealthLivenessGet Liveness Check

	âœ… MEJORA: Kubernetes liveness probe

Returns 200 if the application is alive (not deadlocked)
Used by Kubernetes to restart the pod if unhealthy

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLivenessCheckHealthLivenessGetRequest
	*/
	LivenessCheckHealthLivenessGet(ctx context.Context) ApiLivenessCheckHealthLivenessGetRequest

	// LivenessCheckHealthLivenessGetExecute executes the request
	//  @return interface{}
	LivenessCheckHealthLivenessGetExecute(r ApiLivenessCheckHealthLivenessGetRequest) (interface{}, *http.Response, error)

	/*
	LivenessHealthLiveGet Liveness probe (Kubernetes)

	Kubernetes liveness probe.

Returns 200 if the application is running.
Should restart pod if this fails.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLivenessHealthLiveGetRequest
	*/
	LivenessHealthLiveGet(ctx context.Context) ApiLivenessHealthLiveGetRequest

	// LivenessHealthLiveGetExecute executes the request
	//  @return interface{}
	LivenessHealthLiveGetExecute(r ApiLivenessHealthLiveGetRequest) (interface{}, *http.Response, error)

	/*
	LivenessHealthLiveGet_0 Liveness probe (Kubernetes)

	Kubernetes liveness probe.

Returns 200 if the application is running.
Should restart pod if this fails.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiLivenessHealthLiveGet_0Request
	*/
	LivenessHealthLiveGet_3(ctx context.Context) ApiLivenessHealthLiveGet_0Request

	// LivenessHealthLiveGet_3Execute executes the request
	//  @return interface{}
	LivenessHealthLiveGet_3Execute(r ApiLivenessHealthLiveGet_0Request) (interface{}, *http.Response, error)

	/*
	ReadinessCheckHealthReadinessGet Readiness Check

	âœ… MEJORA: Kubernetes readiness probe

Returns 200 if the application is ready to serve traffic
Checks all critical dependencies (PostgreSQL, Redis, ARQ)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReadinessCheckHealthReadinessGetRequest
	*/
	ReadinessCheckHealthReadinessGet(ctx context.Context) ApiReadinessCheckHealthReadinessGetRequest

	// ReadinessCheckHealthReadinessGetExecute executes the request
	//  @return interface{}
	ReadinessCheckHealthReadinessGetExecute(r ApiReadinessCheckHealthReadinessGetRequest) (interface{}, *http.Response, error)

	/*
	ReadinessHealthReadyGet Readiness probe (Kubernetes)

	Kubernetes readiness probe.

Returns 200 if service is ready to accept traffic.
Checks critical dependencies (Redis).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReadinessHealthReadyGetRequest
	*/
	ReadinessHealthReadyGet(ctx context.Context) ApiReadinessHealthReadyGetRequest

	// ReadinessHealthReadyGetExecute executes the request
	//  @return interface{}
	ReadinessHealthReadyGetExecute(r ApiReadinessHealthReadyGetRequest) (interface{}, *http.Response, error)

	/*
	ReadinessHealthReadyGet_0 Readiness probe (Kubernetes)

	Kubernetes readiness probe.

Returns 200 if service is ready to accept traffic.
Checks critical dependencies (Redis).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReadinessHealthReadyGet_0Request
	*/
	ReadinessHealthReadyGet_4(ctx context.Context) ApiReadinessHealthReadyGet_0Request

	// ReadinessHealthReadyGet_4Execute executes the request
	//  @return interface{}
	ReadinessHealthReadyGet_4Execute(r ApiReadinessHealthReadyGet_0Request) (interface{}, *http.Response, error)

	/*
	ServiceStatusStatusGet Service Status

	âœ… MEJORA: Detailed service status with feature flags

Shows which features are available and which are running in degraded mode

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiServiceStatusStatusGetRequest
	*/
	ServiceStatusStatusGet(ctx context.Context) ApiServiceStatusStatusGetRequest

	// ServiceStatusStatusGetExecute executes the request
	//  @return interface{}
	ServiceStatusStatusGetExecute(r ApiServiceStatusStatusGetRequest) (interface{}, *http.Response, error)

	/*
	StartupCheckHealthStartupGet Startup Check

	âœ… MEJORA: Kubernetes startup probe

Returns 200 once the application has completed startup
Used to delay readiness checks until startup is complete

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStartupCheckHealthStartupGetRequest
	*/
	StartupCheckHealthStartupGet(ctx context.Context) ApiStartupCheckHealthStartupGetRequest

	// StartupCheckHealthStartupGetExecute executes the request
	//  @return interface{}
	StartupCheckHealthStartupGetExecute(r ApiStartupCheckHealthStartupGetRequest) (interface{}, *http.Response, error)
}

// HealthAPIService HealthAPI service
type HealthAPIService service

type ApiBasicHealthHealthGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiBasicHealthHealthGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BasicHealthHealthGetExecute(r)
}

/*
BasicHealthHealthGet Basic health check

Basic health check for load balancers.

Returns 200 if service is running.
Fast response, no dependency checks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBasicHealthHealthGetRequest
*/
func (a *HealthAPIService) BasicHealthHealthGet(ctx context.Context) ApiBasicHealthHealthGetRequest {
	return ApiBasicHealthHealthGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) BasicHealthHealthGetExecute(r ApiBasicHealthHealthGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.BasicHealthHealthGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBasicHealthHealthGet_0Request struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiBasicHealthHealthGet_0Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.BasicHealthHealthGet_1Execute(r)
}

/*
BasicHealthHealthGet_0 Basic health check

Basic health check for load balancers.

Returns 200 if service is running.
Fast response, no dependency checks.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBasicHealthHealthGet_0Request
*/
func (a *HealthAPIService) BasicHealthHealthGet_1(ctx context.Context) ApiBasicHealthHealthGet_0Request {
	return ApiBasicHealthHealthGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) BasicHealthHealthGet_1Execute(r ApiBasicHealthHealthGet_0Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.BasicHealthHealthGet_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.CircuitBreakerStatusAdminCircuitBreakerStatusGetExecute(r)
}

/*
CircuitBreakerStatusAdminCircuitBreakerStatusGet Circuit Breaker Status

âœ… Circuit breaker status for all services.
Shows state of Redis, SMTP, DNS, and other circuit breakers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest
*/
func (a *HealthAPIService) CircuitBreakerStatusAdminCircuitBreakerStatusGet(ctx context.Context) ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest {
	return ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) CircuitBreakerStatusAdminCircuitBreakerStatusGetExecute(r ApiCircuitBreakerStatusAdminCircuitBreakerStatusGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.CircuitBreakerStatusAdminCircuitBreakerStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/admin/circuit-breaker-status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetailedHealthHealthDetailedGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiDetailedHealthHealthDetailedGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DetailedHealthHealthDetailedGetExecute(r)
}

/*
DetailedHealthHealthDetailedGet Detailed health check

Detailed health check with all component statuses.

Returns comprehensive health information for monitoring.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDetailedHealthHealthDetailedGetRequest
*/
func (a *HealthAPIService) DetailedHealthHealthDetailedGet(ctx context.Context) ApiDetailedHealthHealthDetailedGetRequest {
	return ApiDetailedHealthHealthDetailedGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) DetailedHealthHealthDetailedGetExecute(r ApiDetailedHealthHealthDetailedGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.DetailedHealthHealthDetailedGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/detailed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDetailedHealthHealthDetailedGet_0Request struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiDetailedHealthHealthDetailedGet_0Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.DetailedHealthHealthDetailedGet_2Execute(r)
}

/*
DetailedHealthHealthDetailedGet_0 Detailed health check

Detailed health check with all component statuses.

Returns comprehensive health information for monitoring.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDetailedHealthHealthDetailedGet_0Request
*/
func (a *HealthAPIService) DetailedHealthHealthDetailedGet_2(ctx context.Context) ApiDetailedHealthHealthDetailedGet_0Request {
	return ApiDetailedHealthHealthDetailedGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) DetailedHealthHealthDetailedGet_2Execute(r ApiDetailedHealthHealthDetailedGet_0Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.DetailedHealthHealthDetailedGet_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/detailed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthcheckHealthcheckGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiHealthcheckHealthcheckGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.HealthcheckHealthcheckGetExecute(r)
}

/*
HealthcheckHealthcheckGet Healthcheck

Basic health check endpoint (backward compatibility)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthcheckHealthcheckGetRequest
*/
func (a *HealthAPIService) HealthcheckHealthcheckGet(ctx context.Context) ApiHealthcheckHealthcheckGetRequest {
	return ApiHealthcheckHealthcheckGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) HealthcheckHealthcheckGetExecute(r ApiHealthcheckHealthcheckGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.HealthcheckHealthcheckGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/healthcheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHealthcheckHealthcheckHeadRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiHealthcheckHealthcheckHeadRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.HealthcheckHealthcheckHeadExecute(r)
}

/*
HealthcheckHealthcheckHead Healthcheck

Basic health check endpoint (backward compatibility)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHealthcheckHealthcheckHeadRequest
*/
func (a *HealthAPIService) HealthcheckHealthcheckHead(ctx context.Context) ApiHealthcheckHealthcheckHeadRequest {
	return ApiHealthcheckHealthcheckHeadRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) HealthcheckHealthcheckHeadExecute(r ApiHealthcheckHealthcheckHeadRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.HealthcheckHealthcheckHead")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/healthcheck"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLivenessCheckHealthLivenessGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiLivenessCheckHealthLivenessGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.LivenessCheckHealthLivenessGetExecute(r)
}

/*
LivenessCheckHealthLivenessGet Liveness Check

âœ… MEJORA: Kubernetes liveness probe

Returns 200 if the application is alive (not deadlocked)
Used by Kubernetes to restart the pod if unhealthy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLivenessCheckHealthLivenessGetRequest
*/
func (a *HealthAPIService) LivenessCheckHealthLivenessGet(ctx context.Context) ApiLivenessCheckHealthLivenessGetRequest {
	return ApiLivenessCheckHealthLivenessGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) LivenessCheckHealthLivenessGetExecute(r ApiLivenessCheckHealthLivenessGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.LivenessCheckHealthLivenessGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/liveness"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLivenessHealthLiveGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiLivenessHealthLiveGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.LivenessHealthLiveGetExecute(r)
}

/*
LivenessHealthLiveGet Liveness probe (Kubernetes)

Kubernetes liveness probe.

Returns 200 if the application is running.
Should restart pod if this fails.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLivenessHealthLiveGetRequest
*/
func (a *HealthAPIService) LivenessHealthLiveGet(ctx context.Context) ApiLivenessHealthLiveGetRequest {
	return ApiLivenessHealthLiveGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) LivenessHealthLiveGetExecute(r ApiLivenessHealthLiveGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.LivenessHealthLiveGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/live"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLivenessHealthLiveGet_0Request struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiLivenessHealthLiveGet_0Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.LivenessHealthLiveGet_3Execute(r)
}

/*
LivenessHealthLiveGet_0 Liveness probe (Kubernetes)

Kubernetes liveness probe.

Returns 200 if the application is running.
Should restart pod if this fails.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLivenessHealthLiveGet_0Request
*/
func (a *HealthAPIService) LivenessHealthLiveGet_3(ctx context.Context) ApiLivenessHealthLiveGet_0Request {
	return ApiLivenessHealthLiveGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) LivenessHealthLiveGet_3Execute(r ApiLivenessHealthLiveGet_0Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.LivenessHealthLiveGet_3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/live"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadinessCheckHealthReadinessGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiReadinessCheckHealthReadinessGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ReadinessCheckHealthReadinessGetExecute(r)
}

/*
ReadinessCheckHealthReadinessGet Readiness Check

âœ… MEJORA: Kubernetes readiness probe

Returns 200 if the application is ready to serve traffic
Checks all critical dependencies (PostgreSQL, Redis, ARQ)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadinessCheckHealthReadinessGetRequest
*/
func (a *HealthAPIService) ReadinessCheckHealthReadinessGet(ctx context.Context) ApiReadinessCheckHealthReadinessGetRequest {
	return ApiReadinessCheckHealthReadinessGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) ReadinessCheckHealthReadinessGetExecute(r ApiReadinessCheckHealthReadinessGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.ReadinessCheckHealthReadinessGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/readiness"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadinessHealthReadyGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiReadinessHealthReadyGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ReadinessHealthReadyGetExecute(r)
}

/*
ReadinessHealthReadyGet Readiness probe (Kubernetes)

Kubernetes readiness probe.

Returns 200 if service is ready to accept traffic.
Checks critical dependencies (Redis).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadinessHealthReadyGetRequest
*/
func (a *HealthAPIService) ReadinessHealthReadyGet(ctx context.Context) ApiReadinessHealthReadyGetRequest {
	return ApiReadinessHealthReadyGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) ReadinessHealthReadyGetExecute(r ApiReadinessHealthReadyGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.ReadinessHealthReadyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadinessHealthReadyGet_0Request struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiReadinessHealthReadyGet_0Request) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ReadinessHealthReadyGet_4Execute(r)
}

/*
ReadinessHealthReadyGet_0 Readiness probe (Kubernetes)

Kubernetes readiness probe.

Returns 200 if service is ready to accept traffic.
Checks critical dependencies (Redis).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadinessHealthReadyGet_0Request
*/
func (a *HealthAPIService) ReadinessHealthReadyGet_4(ctx context.Context) ApiReadinessHealthReadyGet_0Request {
	return ApiReadinessHealthReadyGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) ReadinessHealthReadyGet_4Execute(r ApiReadinessHealthReadyGet_0Request) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.ReadinessHealthReadyGet_4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiServiceStatusStatusGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiServiceStatusStatusGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.ServiceStatusStatusGetExecute(r)
}

/*
ServiceStatusStatusGet Service Status

âœ… MEJORA: Detailed service status with feature flags

Shows which features are available and which are running in degraded mode

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiServiceStatusStatusGetRequest
*/
func (a *HealthAPIService) ServiceStatusStatusGet(ctx context.Context) ApiServiceStatusStatusGetRequest {
	return ApiServiceStatusStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) ServiceStatusStatusGetExecute(r ApiServiceStatusStatusGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.ServiceStatusStatusGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStartupCheckHealthStartupGetRequest struct {
	ctx context.Context
	ApiService HealthAPI
}

func (r ApiStartupCheckHealthStartupGetRequest) Execute() (interface{}, *http.Response, error) {
	return r.ApiService.StartupCheckHealthStartupGetExecute(r)
}

/*
StartupCheckHealthStartupGet Startup Check

âœ… MEJORA: Kubernetes startup probe

Returns 200 once the application has completed startup
Used to delay readiness checks until startup is complete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStartupCheckHealthStartupGetRequest
*/
func (a *HealthAPIService) StartupCheckHealthStartupGet(ctx context.Context) ApiStartupCheckHealthStartupGetRequest {
	return ApiStartupCheckHealthStartupGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return interface{}
func (a *HealthAPIService) StartupCheckHealthStartupGetExecute(r ApiStartupCheckHealthStartupGetRequest) (interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HealthAPIService.StartupCheckHealthStartupGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/health/startup"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
