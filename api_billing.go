/*
Email Validation API ‚Äî Enterprise-grade Email Verification

API robusta y segura para validaci√≥n y verificaci√≥n de correos electr√≥nicos. Soporta verificaci√≥n individual y en lote, detecci√≥n de brechas, y autenticaci√≥n JWT. Cumple con GDPR y dispone de planes de pago flexibles.  **üîó Enlaces importantes:** - [Estado del sistema](https://mailsafepro.betteruptime.com) - [Documentaci√≥n completa](https://email-validation-api-jlra.onrender.com/redoc)  **üìß Contacto:** mailsafepro1@gmail.com

API version: 2.5.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mailsafepro

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type BillingAPI interface {

	/*
	ChangePlanBillingBillingChangePlanPost Change Plan

	Cambiar el plan del usuario.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChangePlanBillingBillingChangePlanPostRequest
	*/
	ChangePlanBillingBillingChangePlanPost(ctx context.Context) ApiChangePlanBillingBillingChangePlanPostRequest

	// ChangePlanBillingBillingChangePlanPostExecute executes the request
	//  @return map[string]interface{}
	ChangePlanBillingBillingChangePlanPostExecute(r ApiChangePlanBillingBillingChangePlanPostRequest) (map[string]interface{}, *http.Response, error)

	/*
	ChangePlanBillingBillingChangePlanPost_0 Change Plan

	Cambiar el plan del usuario.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiChangePlanBillingBillingChangePlanPost_0Request
	*/
	ChangePlanBillingBillingChangePlanPost_1(ctx context.Context) ApiChangePlanBillingBillingChangePlanPost_0Request

	// ChangePlanBillingBillingChangePlanPost_1Execute executes the request
	//  @return map[string]interface{}
	ChangePlanBillingBillingChangePlanPost_1Execute(r ApiChangePlanBillingBillingChangePlanPost_0Request) (map[string]interface{}, *http.Response, error)

	/*
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost Create Checkout Session

	Crea una checkout session de Stripe para suscripci√≥n.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest
	*/
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost(ctx context.Context) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest

	// CreateCheckoutSessionBillingBillingCreateCheckoutSessionPostExecute executes the request
	//  @return CheckoutSessionResponse
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPostExecute(r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest) (*CheckoutSessionResponse, *http.Response, error)

	/*
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0 Create Checkout Session

	Crea una checkout session de Stripe para suscripci√≥n.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request
	*/
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2(ctx context.Context) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request

	// CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2Execute executes the request
	//  @return CheckoutSessionResponse
	CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2Execute(r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request) (*CheckoutSessionResponse, *http.Response, error)

	/*
	GetSubscriptionBillingBillingSubscriptionGet Get Subscription

	Devuelve informaci√≥n de suscripci√≥n (plan y pr√≥xima fecha de cobro).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubscriptionBillingBillingSubscriptionGetRequest
	*/
	GetSubscriptionBillingBillingSubscriptionGet(ctx context.Context) ApiGetSubscriptionBillingBillingSubscriptionGetRequest

	// GetSubscriptionBillingBillingSubscriptionGetExecute executes the request
	//  @return SubscriptionResponse
	GetSubscriptionBillingBillingSubscriptionGetExecute(r ApiGetSubscriptionBillingBillingSubscriptionGetRequest) (*SubscriptionResponse, *http.Response, error)

	/*
	GetSubscriptionBillingBillingSubscriptionGet_0 Get Subscription

	Devuelve informaci√≥n de suscripci√≥n (plan y pr√≥xima fecha de cobro).

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubscriptionBillingBillingSubscriptionGet_0Request
	*/
	GetSubscriptionBillingBillingSubscriptionGet_3(ctx context.Context) ApiGetSubscriptionBillingBillingSubscriptionGet_0Request

	// GetSubscriptionBillingBillingSubscriptionGet_3Execute executes the request
	//  @return SubscriptionResponse
	GetSubscriptionBillingBillingSubscriptionGet_3Execute(r ApiGetSubscriptionBillingBillingSubscriptionGet_0Request) (*SubscriptionResponse, *http.Response, error)

	/*
	StripeWebhookBillingBillingWebhookPost Stripe Webhook

	Webhook de Stripe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStripeWebhookBillingBillingWebhookPostRequest
	*/
	StripeWebhookBillingBillingWebhookPost(ctx context.Context) ApiStripeWebhookBillingBillingWebhookPostRequest

	// StripeWebhookBillingBillingWebhookPostExecute executes the request
	//  @return WebhookResponse
	StripeWebhookBillingBillingWebhookPostExecute(r ApiStripeWebhookBillingBillingWebhookPostRequest) (*WebhookResponse, *http.Response, error)

	/*
	StripeWebhookBillingBillingWebhookPost_0 Stripe Webhook

	Webhook de Stripe.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiStripeWebhookBillingBillingWebhookPost_0Request
	*/
	StripeWebhookBillingBillingWebhookPost_4(ctx context.Context) ApiStripeWebhookBillingBillingWebhookPost_0Request

	// StripeWebhookBillingBillingWebhookPost_4Execute executes the request
	//  @return WebhookResponse
	StripeWebhookBillingBillingWebhookPost_4Execute(r ApiStripeWebhookBillingBillingWebhookPost_0Request) (*WebhookResponse, *http.Response, error)

	/*
	TestNotificationBillingBillingTestNotificationPost Test Notification

	Env√≠a un email de prueba de cambio de plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestNotificationBillingBillingTestNotificationPostRequest
	*/
	TestNotificationBillingBillingTestNotificationPost(ctx context.Context) ApiTestNotificationBillingBillingTestNotificationPostRequest

	// TestNotificationBillingBillingTestNotificationPostExecute executes the request
	//  @return map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
	TestNotificationBillingBillingTestNotificationPostExecute(r ApiTestNotificationBillingBillingTestNotificationPostRequest) (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error)

	/*
	TestNotificationBillingBillingTestNotificationPost_0 Test Notification

	Env√≠a un email de prueba de cambio de plan.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiTestNotificationBillingBillingTestNotificationPost_0Request
	*/
	TestNotificationBillingBillingTestNotificationPost_5(ctx context.Context) ApiTestNotificationBillingBillingTestNotificationPost_0Request

	// TestNotificationBillingBillingTestNotificationPost_5Execute executes the request
	//  @return map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
	TestNotificationBillingBillingTestNotificationPost_5Execute(r ApiTestNotificationBillingBillingTestNotificationPost_0Request) (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error)
}

// BillingAPIService BillingAPI service
type BillingAPIService service

type ApiChangePlanBillingBillingChangePlanPostRequest struct {
	ctx context.Context
	ApiService BillingAPI
	bodyChangePlanBillingBillingChangePlanPost *BodyChangePlanBillingBillingChangePlanPost
}

func (r ApiChangePlanBillingBillingChangePlanPostRequest) BodyChangePlanBillingBillingChangePlanPost(bodyChangePlanBillingBillingChangePlanPost BodyChangePlanBillingBillingChangePlanPost) ApiChangePlanBillingBillingChangePlanPostRequest {
	r.bodyChangePlanBillingBillingChangePlanPost = &bodyChangePlanBillingBillingChangePlanPost
	return r
}

func (r ApiChangePlanBillingBillingChangePlanPostRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChangePlanBillingBillingChangePlanPostExecute(r)
}

/*
ChangePlanBillingBillingChangePlanPost Change Plan

Cambiar el plan del usuario.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangePlanBillingBillingChangePlanPostRequest
*/
func (a *BillingAPIService) ChangePlanBillingBillingChangePlanPost(ctx context.Context) ApiChangePlanBillingBillingChangePlanPostRequest {
	return ApiChangePlanBillingBillingChangePlanPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BillingAPIService) ChangePlanBillingBillingChangePlanPostExecute(r ApiChangePlanBillingBillingChangePlanPostRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ChangePlanBillingBillingChangePlanPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/change-plan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyChangePlanBillingBillingChangePlanPost == nil {
		return localVarReturnValue, nil, reportError("bodyChangePlanBillingBillingChangePlanPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyChangePlanBillingBillingChangePlanPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangePlanBillingBillingChangePlanPost_0Request struct {
	ctx context.Context
	ApiService BillingAPI
	bodyChangePlanBillingBillingChangePlanPost *BodyChangePlanBillingBillingChangePlanPost
}

func (r ApiChangePlanBillingBillingChangePlanPost_0Request) BodyChangePlanBillingBillingChangePlanPost(bodyChangePlanBillingBillingChangePlanPost BodyChangePlanBillingBillingChangePlanPost) ApiChangePlanBillingBillingChangePlanPost_0Request {
	r.bodyChangePlanBillingBillingChangePlanPost = &bodyChangePlanBillingBillingChangePlanPost
	return r
}

func (r ApiChangePlanBillingBillingChangePlanPost_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ChangePlanBillingBillingChangePlanPost_1Execute(r)
}

/*
ChangePlanBillingBillingChangePlanPost_0 Change Plan

Cambiar el plan del usuario.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangePlanBillingBillingChangePlanPost_0Request
*/
func (a *BillingAPIService) ChangePlanBillingBillingChangePlanPost_1(ctx context.Context) ApiChangePlanBillingBillingChangePlanPost_0Request {
	return ApiChangePlanBillingBillingChangePlanPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *BillingAPIService) ChangePlanBillingBillingChangePlanPost_1Execute(r ApiChangePlanBillingBillingChangePlanPost_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.ChangePlanBillingBillingChangePlanPost_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/change-plan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bodyChangePlanBillingBillingChangePlanPost == nil {
		return localVarReturnValue, nil, reportError("bodyChangePlanBillingBillingChangePlanPost is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bodyChangePlanBillingBillingChangePlanPost
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest struct {
	ctx context.Context
	ApiService BillingAPI
	checkoutRequest *CheckoutRequest
}

func (r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest) CheckoutRequest(checkoutRequest CheckoutRequest) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest {
	r.checkoutRequest = &checkoutRequest
	return r
}

func (r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest) Execute() (*CheckoutSessionResponse, *http.Response, error) {
	return r.ApiService.CreateCheckoutSessionBillingBillingCreateCheckoutSessionPostExecute(r)
}

/*
CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost Create Checkout Session

Crea una checkout session de Stripe para suscripci√≥n.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest
*/
func (a *BillingAPIService) CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost(ctx context.Context) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest {
	return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckoutSessionResponse
func (a *BillingAPIService) CreateCheckoutSessionBillingBillingCreateCheckoutSessionPostExecute(r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPostRequest) (*CheckoutSessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckoutSessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/create-checkout-session"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkoutRequest == nil {
		return localVarReturnValue, nil, reportError("checkoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request struct {
	ctx context.Context
	ApiService BillingAPI
	checkoutRequest *CheckoutRequest
}

func (r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request) CheckoutRequest(checkoutRequest CheckoutRequest) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request {
	r.checkoutRequest = &checkoutRequest
	return r
}

func (r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request) Execute() (*CheckoutSessionResponse, *http.Response, error) {
	return r.ApiService.CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2Execute(r)
}

/*
CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0 Create Checkout Session

Crea una checkout session de Stripe para suscripci√≥n.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request
*/
func (a *BillingAPIService) CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2(ctx context.Context) ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request {
	return ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CheckoutSessionResponse
func (a *BillingAPIService) CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2Execute(r ApiCreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_0Request) (*CheckoutSessionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CheckoutSessionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.CreateCheckoutSessionBillingBillingCreateCheckoutSessionPost_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/create-checkout-session"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.checkoutRequest == nil {
		return localVarReturnValue, nil, reportError("checkoutRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.checkoutRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionBillingBillingSubscriptionGetRequest struct {
	ctx context.Context
	ApiService BillingAPI
	xAPIKey *string
	authorization *string
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGetRequest) XAPIKey(xAPIKey string) ApiGetSubscriptionBillingBillingSubscriptionGetRequest {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGetRequest) Authorization(authorization string) ApiGetSubscriptionBillingBillingSubscriptionGetRequest {
	r.authorization = &authorization
	return r
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGetRequest) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionBillingBillingSubscriptionGetExecute(r)
}

/*
GetSubscriptionBillingBillingSubscriptionGet Get Subscription

Devuelve informaci√≥n de suscripci√≥n (plan y pr√≥xima fecha de cobro).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubscriptionBillingBillingSubscriptionGetRequest
*/
func (a *BillingAPIService) GetSubscriptionBillingBillingSubscriptionGet(ctx context.Context) ApiGetSubscriptionBillingBillingSubscriptionGetRequest {
	return ApiGetSubscriptionBillingBillingSubscriptionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *BillingAPIService) GetSubscriptionBillingBillingSubscriptionGetExecute(r ApiGetSubscriptionBillingBillingSubscriptionGetRequest) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetSubscriptionBillingBillingSubscriptionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-API-Key", r.xAPIKey, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubscriptionBillingBillingSubscriptionGet_0Request struct {
	ctx context.Context
	ApiService BillingAPI
	xAPIKey *string
	authorization *string
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGet_0Request) XAPIKey(xAPIKey string) ApiGetSubscriptionBillingBillingSubscriptionGet_0Request {
	r.xAPIKey = &xAPIKey
	return r
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGet_0Request) Authorization(authorization string) ApiGetSubscriptionBillingBillingSubscriptionGet_0Request {
	r.authorization = &authorization
	return r
}

func (r ApiGetSubscriptionBillingBillingSubscriptionGet_0Request) Execute() (*SubscriptionResponse, *http.Response, error) {
	return r.ApiService.GetSubscriptionBillingBillingSubscriptionGet_3Execute(r)
}

/*
GetSubscriptionBillingBillingSubscriptionGet_0 Get Subscription

Devuelve informaci√≥n de suscripci√≥n (plan y pr√≥xima fecha de cobro).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSubscriptionBillingBillingSubscriptionGet_0Request
*/
func (a *BillingAPIService) GetSubscriptionBillingBillingSubscriptionGet_3(ctx context.Context) ApiGetSubscriptionBillingBillingSubscriptionGet_0Request {
	return ApiGetSubscriptionBillingBillingSubscriptionGet_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SubscriptionResponse
func (a *BillingAPIService) GetSubscriptionBillingBillingSubscriptionGet_3Execute(r ApiGetSubscriptionBillingBillingSubscriptionGet_0Request) (*SubscriptionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubscriptionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.GetSubscriptionBillingBillingSubscriptionGet_3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/subscription"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xAPIKey != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "X-API-Key", r.xAPIKey, "simple", "")
	}
	if r.authorization != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "authorization", r.authorization, "simple", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStripeWebhookBillingBillingWebhookPostRequest struct {
	ctx context.Context
	ApiService BillingAPI
}

func (r ApiStripeWebhookBillingBillingWebhookPostRequest) Execute() (*WebhookResponse, *http.Response, error) {
	return r.ApiService.StripeWebhookBillingBillingWebhookPostExecute(r)
}

/*
StripeWebhookBillingBillingWebhookPost Stripe Webhook

Webhook de Stripe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStripeWebhookBillingBillingWebhookPostRequest
*/
func (a *BillingAPIService) StripeWebhookBillingBillingWebhookPost(ctx context.Context) ApiStripeWebhookBillingBillingWebhookPostRequest {
	return ApiStripeWebhookBillingBillingWebhookPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookResponse
func (a *BillingAPIService) StripeWebhookBillingBillingWebhookPostExecute(r ApiStripeWebhookBillingBillingWebhookPostRequest) (*WebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.StripeWebhookBillingBillingWebhookPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStripeWebhookBillingBillingWebhookPost_0Request struct {
	ctx context.Context
	ApiService BillingAPI
}

func (r ApiStripeWebhookBillingBillingWebhookPost_0Request) Execute() (*WebhookResponse, *http.Response, error) {
	return r.ApiService.StripeWebhookBillingBillingWebhookPost_4Execute(r)
}

/*
StripeWebhookBillingBillingWebhookPost_0 Stripe Webhook

Webhook de Stripe.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStripeWebhookBillingBillingWebhookPost_0Request
*/
func (a *BillingAPIService) StripeWebhookBillingBillingWebhookPost_4(ctx context.Context) ApiStripeWebhookBillingBillingWebhookPost_0Request {
	return ApiStripeWebhookBillingBillingWebhookPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return WebhookResponse
func (a *BillingAPIService) StripeWebhookBillingBillingWebhookPost_4Execute(r ApiStripeWebhookBillingBillingWebhookPost_0Request) (*WebhookResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebhookResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.StripeWebhookBillingBillingWebhookPost_4")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/webhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestNotificationBillingBillingTestNotificationPostRequest struct {
	ctx context.Context
	ApiService BillingAPI
	requestBody *map[string]string
}

func (r ApiTestNotificationBillingBillingTestNotificationPostRequest) RequestBody(requestBody map[string]string) ApiTestNotificationBillingBillingTestNotificationPostRequest {
	r.requestBody = &requestBody
	return r
}

func (r ApiTestNotificationBillingBillingTestNotificationPostRequest) Execute() (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error) {
	return r.ApiService.TestNotificationBillingBillingTestNotificationPostExecute(r)
}

/*
TestNotificationBillingBillingTestNotificationPost Test Notification

Env√≠a un email de prueba de cambio de plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestNotificationBillingBillingTestNotificationPostRequest
*/
func (a *BillingAPIService) TestNotificationBillingBillingTestNotificationPost(ctx context.Context) ApiTestNotificationBillingBillingTestNotificationPostRequest {
	return ApiTestNotificationBillingBillingTestNotificationPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
func (a *BillingAPIService) TestNotificationBillingBillingTestNotificationPostExecute(r ApiTestNotificationBillingBillingTestNotificationPostRequest) (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.TestNotificationBillingBillingTestNotificationPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/test-notification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestNotificationBillingBillingTestNotificationPost_0Request struct {
	ctx context.Context
	ApiService BillingAPI
	requestBody *map[string]string
}

func (r ApiTestNotificationBillingBillingTestNotificationPost_0Request) RequestBody(requestBody map[string]string) ApiTestNotificationBillingBillingTestNotificationPost_0Request {
	r.requestBody = &requestBody
	return r
}

func (r ApiTestNotificationBillingBillingTestNotificationPost_0Request) Execute() (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error) {
	return r.ApiService.TestNotificationBillingBillingTestNotificationPost_5Execute(r)
}

/*
TestNotificationBillingBillingTestNotificationPost_0 Test Notification

Env√≠a un email de prueba de cambio de plan.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestNotificationBillingBillingTestNotificationPost_0Request
*/
func (a *BillingAPIService) TestNotificationBillingBillingTestNotificationPost_5(ctx context.Context) ApiTestNotificationBillingBillingTestNotificationPost_0Request {
	return ApiTestNotificationBillingBillingTestNotificationPost_0Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
func (a *BillingAPIService) TestNotificationBillingBillingTestNotificationPost_5Execute(r ApiTestNotificationBillingBillingTestNotificationPost_0Request) (*map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]ResponseTestNotificationBillingBillingTestNotificationPostValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BillingAPIService.TestNotificationBillingBillingTestNotificationPost_5")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/billing/billing/test-notification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
